# 相关参考
游戏开发中的阻尼器和阻尼弹簧	[https://zhuanlan.zhihu.com/p/461813778](https://zhuanlan.zhihu.com/p/461813778)
相机基础流程 [https://mp.weixin.qq.com/s?__biz=MzUxMDM3MTYwNQ==&mid=2247515300&idx=1&sn=9d5541a39509ee76f352f71b5d23396d&chksm=f9010edece7687c873df25965408a79c6097321ae8be62e61f9d5a164ddd36047acd1810851e&token=1293963636&lang=zh_CN#rd](https://mp.weixin.qq.com/s?__biz=MzUxMDM3MTYwNQ==&mid=2247515300&idx=1&sn=9d5541a39509ee76f352f71b5d23396d&chksm=f9010edece7687c873df25965408a79c6097321ae8be62e61f9d5a164ddd36047acd1810851e&token=1293963636&lang=zh_CN#rd)
# 基础概念
**位置**、**朝向**、**视野(**FOV) 这三个参数是相机系统最核心的内容，把他们组装起来就是常说的 POV（Point Of View，还包含其它的参数），你会在代码中经常看到它
# 基础更新流程
## PlayerController
Playercontroller 管理了相机管理类 APlayerCameraManager
```cpp
	/** Camera manager associated with this Player Controller. */
	UPROPERTY(BlueprintReadOnly, Category=PlayerController)
	TObjectPtr<APlayerCameraManager> PlayerCameraManager;
```
在关卡的 Tick 中 获取当前的 PlayerController 然后调用 UpdateCameraManager 接口来更新相机
```cpp
// Update cameras last. This needs to be done before NetUpdates, and after all actors have been ticked.
for( FConstPlayerControllerIterator Iterator = GetPlayerControllerIterator(); Iterator; ++Iterator )
{
    if (APlayerController* PlayerController = Iterator->Get())
    {
        if (!bIsPaused || PlayerController->ShouldPerformFullTickWhenPaused())
        {
            PlayerController->UpdateCameraManager(DeltaSeconds);
        }
        else if (PlayerController->PlayerCameraManager && FCameraPhotographyManager::IsSupported(this))
        {
            PlayerController->PlayerCameraManager->UpdateCameraPhotographyOnly();
        }
    }
}
```
下一步 PlayerController 的更新接口 UpdateCameraManager 调用 PlayerCameraManager 的更新接口 UpdateCamera 进行真正的相机逻辑更新
## PlayerCameraManager
上面说到 PlayerCameraManager 里的接口 UpdateCamera 是真正执行相机 POV 更新的地方，UpdateCamera 接口会调用 DoUpdateCamera
PlayerCameraManager 的 UpdateCamera 方法主要逻辑如下：

- DoUpdateCamera 处理 ViewTarget 和 PendingViewTarget 的**更新**(调用 UpdateViewTarget )与**融合**逻辑
- UpdateViewTarget 根据 ViewTarget 内的 Target 计算对应的 POV 信息**（核心逻辑）**
- ApplyCameraModifiers 处理特殊的镜头需求；比如：CameraShake、粒子效果等
- UpdateCameraLensEffects 处理特殊镜头效果；比如：景深、边缘模糊、色彩校正等
- 缓存相机数据 FillCameraCache (NewPOV)，用于渲染
```cpp
void APlayerCameraManager::UpdateCamera(float DeltaTime)
{
	check(PCOwner != nullptr);

	if ((PCOwner->Player && PCOwner->IsLocalPlayerController()) || !bUseClientSideCameraUpdates || bDebugClientSideCamera)
	{
        // 省略部分的代码
		DoUpdateCamera(DeltaTime);
    	UpdateViewTarget(ViewTarget, DeltaTime);
        ApplyCameraModifiers(DeltaTime, OutVT.POV);
        UpdateCameraLensEffects(OutVT);
    }
```
下面的代码是 DoUpdateCamera 的部分逻辑
```cpp
void APlayerCameraManager::DoUpdateCamera(float DeltaTime)
{
	FMinimalViewInfo NewPOV = ViewTarget.POV;

	// 省略部分代码
	// Don't update outgoing viewtarget during an interpolation when bLockOutgoing is set.
	if ((PendingViewTarget.Target == NULL) || !BlendParams.bLockOutgoing)
	{
		// Update current view target
		ViewTarget.CheckViewTarget(PCOwner);
		UpdateViewTarget(ViewTarget, DeltaTime);
	}

	// 省略部分代码

	// if we have a pending view target, perform transition from one to another.
	if (PendingViewTarget.Target != NULL)
	{
        // 省略部分代码
		// Update pending view target
		PendingViewTarget.CheckViewTarget(PCOwner);
		UpdateViewTarget(PendingViewTarget, DeltaTime);

        // 省略下面部分的代码
    }
}
```
PlayerCameraManger 根据 ViewTarget 内 Target 对象的信息来计算并刷新 POV，随后这个 POV 信息会被 ULocalPlayer 用到渲染的透视投影或正交投影矩阵中，将相机视野范围内的内容渲染到屏幕上
在 DoUpdateCamera 接口内存在一个关键的信息结构 FMinimalViewInfo & 关键的接口 UpdateViewTarget，而且 PlayerCameraManager 中 存储了 ViewTarget（FTViewTarget），FTViewTarget结构如下
```cpp
/** A ViewTarget is the primary actor the camera is associated with. */
USTRUCT(BlueprintType)
struct ENGINE_API FTViewTarget
{
	// 相机跟随的目标
	/** Target Actor used to compute POV */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TViewTarget)
	TObjectPtr<class AActor> Target;

	// 摄像机实际的POV
	/** Computed point of view */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TViewTarget)
	struct FMinimalViewInfo POV;

	// 省略部分代码
};
```
在 DoUpdateCamera 接口里调用 UpdateViewTarget 接口根据跟随目标 计算相机的新的 POV 位置，而 UpdateViewTarget 又是根据 相机组件的接口 GetCameraView 获取新的相机 POV 信息，如下图
```cpp
void APlayerCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)
{
	// 省略部分代码
	if (ACameraActor* CamActor = Cast<ACameraActor>(OutVT.Target))
	{
		// Viewing through a camera actor.
		CamActor->GetCameraComponent()->GetCameraView(DeltaTime, OutVT.POV);
	}
    // 省略部分代码
}
```
GetCameraView 是一个虚函数，可以通过自定义的相机组件 NCameraComponent 来 根据不同的相机模式策略更新相机 DesiredView 信息
相机修改的关键干涉点是修改相机的POV，即通过 相机组件CameraComponent 重写 GetCameraView 接口来实现自定义修改过后的 FMinimalViewInfo 信息，DesiredView 的信息是相机组件最终的位置信息
```cpp
virtual void GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView) override;

void UNCameraComponent::GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView)
{
	FNCameraModeView CameraModeView;
	// 没有设置相机模式走父类逻辑；否则走相机模式逻辑
	if (!CameraModeStack || (!CameraModeStack->EvaluateStack(DeltaTime, CameraModeView)))
	{
		Super::GetCameraView(DeltaTime, DesiredView);
	}
	else
	{
		// Keep player controller in sync with the latest view.
		if (APawn* TargetPawn = Cast<APawn>(GetParentActor()))
		{
			if (APlayerController* PC = TargetPawn->GetController<APlayerController>())
			{
				PC->SetControlRotation(CameraModeView.ControlRotation);
			}
		}
		GetPOICameraManager()->UpdateRotation(DeltaTime,CameraModeView);
		// Keep camera component in sync with the latest view.
		SetWorldLocationAndRotation(CameraModeView.Location, CameraModeView.Rotation);
		FieldOfView = CameraModeView.FieldOfView;

		// Fill in desired view.
		DesiredView.Location = CameraModeView.Location;
		DesiredView.Rotation = CameraModeView.Rotation;
		DesiredView.FOV = CameraModeView.FieldOfView;
		DesiredView.OrthoWidth = OrthoWidth;
		DesiredView.OrthoNearClipPlane = OrthoNearClipPlane;
		DesiredView.OrthoFarClipPlane = OrthoFarClipPlane;
		DesiredView.AspectRatio = AspectRatio;
		DesiredView.bConstrainAspectRatio = bConstrainAspectRatio;
		DesiredView.bUseFieldOfViewForLOD = bUseFieldOfViewForLOD;
		DesiredView.ProjectionMode = ProjectionMode;
		// See if the CameraActor wants to override the PostProcess settings used.
		DesiredView.PostProcessBlendWeight = PostProcessBlendWeight;
		if (PostProcessBlendWeight > 0.0f)
		{
			DesiredView.PostProcessSettings = PostProcessSettings;
		}	
	}
}
```
# 基本构成
## 相机组件 CameraComponent
### 成员
相机模式栈 	UNCameraModeStack* CameraModeStack;
默认相机模式 	TSubclassOf<UNCameraModeBase> DefaultCameraMode;
半透效果配置 	FNActorFading ActorFadingProp;

# 部分效果拆解
## 过渡
原神：
攀爬相机： 原神的攀爬相机是在当前相机臂长进行了一些延申，并非固定到了一个指定臂长，和目前的相机模式切换机制不兼容（考虑是否采取类似区域镜头的方式实现，需要优化下区域相机相关的逻辑看看怎么通用，可能会采取区域优先级的方式通过 攀爬以及滑翔以及游泳，那么这些状态就不存在独立的相机了，但是这只局限于休闲相机进入这三种模式，如果是其他相机进入这种模式应当如何处理还是需要独立相机亦或在当前相机上进行叠加，区域相机要区分如何设置才能只叠加到休闲相机上，需要考虑的是如果是其他相机进入了）
