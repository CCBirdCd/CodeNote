手柄焦点
## UI要求
### 1 需要可被手柄交互的UI继承自 LLActivatableWidget
![[Image/手柄焦点/752b55ece67c6a55433c4bf2d5987b15_MD5.png]]
### 2 UI上打上标记属于某一层级，UI根据类型被放置到不同的Stack中，同一Stack有新的入栈UI旧的UI会被隐藏（忽略）
### 3 UI需要设置导航
![[Image/手柄焦点/d9761b7e12dc5a2fb719a2a19496471c_MD5.png]]
对于上图UI，默认导航是不能从 按钮 444 移动到 按钮 Opitions 的,按照如图所示方式可以让导航 444 走到Options
下面的三个图反映了另一个问题，当我将  Yes按钮 的向上导航设置为默认自动导航，将Cancel按钮 设置为 禁止向上导航的时候，这个弹窗层下面还有一个 可以手柄交互的UI，当焦点处于 Yes按钮的时候 推动摇杆向上光标会自动导航到 按钮444，反之由于对 按钮Cancel 设置了禁止向上导航，当焦点在 按钮Cancel 上的时候推动摇杆向上则不会导航到 按钮444（参考下面第三个图）
![[Image/手柄焦点/cace9ccacb61dd1c0e0b7f232303b9e2_MD5.png]]
![[Image/手柄焦点/80a055ef7df8a3bce690089689215ee3_MD5.png]]
![[Image/手柄焦点/54a225c9a332e7289dc957196454e501_MD5.png]]
### 4 焦点设置
![[Image/手柄焦点/b347ce274393659d1a260fc55e19e713_MD5.png]]
当玩家打开一个新的页面的页面的时候需要设置一个默认的焦点对象，对于下面这个界面，当我们打开这个页面期望光标默认处于 Yes按钮 时，需要在UI里重写下这个函数添加一下默认的焦点控件
![[Image/手柄焦点/f02e06c3eae1f4917bbb5f97bf51e069_MD5.png]]
![[Image/手柄焦点/20722e7b92f92e0fe5ebdb2819614378_MD5.png]]
并且对于期望可以 导航的按钮需要设置Focusable参考下图
![[Image/手柄焦点/c0e701b4ba1111f92434ecc1bf70d5aa_MD5.png]]
当期望子UI关闭后焦点恢复到之前所在的UI需要设置如下图
![[Image/手柄焦点/851c475c7253a79fe019ea78900df21f_MD5.png]]
**当在一些情况下需要自动恢复焦点（鼠标手柄切换之类的情况）需要勾选如下配置**
![[Image/手柄焦点/8c0a2ee5376822d6aaf5db52333afaf7_MD5.png]]
### 5. CommonButtonBase
![[Image/手柄焦点/203cfcb54fa10b4aeb9583ee43dde35d_MD5.png]]
### 6.  CommonUI支持绑定InputAction
不过需要封装，感觉像是没写完，需要改源码，按键绑定的时候找不到按键配置信息
## 使用stack的话 ui不能层叠新widget会导致旧的widget隐藏
![[Image/手柄焦点/d1470ee0075f34e7faadfdbd9ee2b8df_MD5.png]]
## 如果UI要注册 back导航 需要勾选 IsBackHandler,进一步可以重写 Handle backaction 例如deactive自身
## 程序处理
### **CommonUI特有功能**
⭐⭐**自带过渡效果**：在Stack控件的Detail-Transition中可以设置控件激活/注销时过渡效果，同时还可以设置效果曲线类型与曲线数值。默认是**渐隐(Fade Only)**。
⭐⭐⭐**CommonActivatableWidgetStack**：会自动激活Stack顶部Widget。
⭐BackHandle：后退动作处理，除了勾选BackHandle与IsModel之外，需要还需重写OnHandleBackAction()
### CommonActivaableWidgetStack
![[Image/手柄焦点/69f660b804ceb15cffb188ef892e85aa_MD5.png]]
函数来管理内部CommonActivatableWidget的 "**activated** "和 "**deactivated**"。
CommonAnimatedSwitcher：继承自UWidgetSwitcher，主要实现了过渡动画（具体在Slate控件里）以及OnActiveWidgetIndexChanged、OnTransitioningChanged委托。
### CommonActivaableWidgetStack
继承自UCommonActivatableWidgetContainerBase，重写OnWidgetAddedToList()，添加控件时并显示末尾控件
### CommonActivaableWidgetQueue
继承自UCommonActivatableWidgetContainerBase，重写OnWidgetAddedToList()，添加控件时并显示第一个控件
### 导航
![[Image/手柄焦点/c50c3b377f13328a515b320ee9a5f43a_MD5.png]]
## 控件类型实现思路
### 5 TabListWidget 导航菜单
![[Image/手柄焦点/88833ac9b2c7a3f5d50721c76df74943_MD5.png]]
参考项目Lyra：
![[Image/手柄焦点/e96836834daeacf2bbacaf55bd7fcfe8_MD5.png]]
如上图所示 红色 框起来的区域看起来是两个按键提示，但在UI中其实是两个按钮，通过注册手柄的左右肩按键绑定到tablistwidget的输入设置来实现自动切换，如下图右侧红框将tablistwidget的左右导航分别绑定了左右肩键
![[Image/手柄焦点/d2e472983b8f09c4fafa0b04df8486df_MD5.png]]
来实现Tab页签的切换
![[Image/手柄焦点/b97fb9291fc6953651acaec5009d3c0a_MD5.png]]
![[Image/手柄焦点/7aa52258de0db280a6fee4d84d04627e_MD5.png]]
![[Image/手柄焦点/4fe433d12a05a38796e2183797ea0006_MD5.png]]
需要注意的是当我们期望在Tablist列表的左右侧显示按钮图标需要进行一定的配置，目前的项目配置路径于下图（表示左右肩按键对应显示的图标）
![[Image/手柄焦点/ad0f775692a6659253cfcb6997680c50_MD5.png]]
我们需要对要显示图标的按钮进行一下按键绑定，参考下图
![[Image/手柄焦点/237cc63d4ad6d1d0e829897e62555831_MD5.png]]
代码模块位于下图，当逻辑找不到按钮对应的图标的时候是不会显示的
![[Image/手柄焦点/348835f0c57f14d35c75be90dca436c4_MD5.png]]
### 6 BoundActionBar & BoundActionButton 导航界面快捷键
![[Image/手柄焦点/5c91005d40e47de8a6279dfe86721b8b_MD5.png]]
![[Image/手柄焦点/8e433831650d8bcd280dd4e8011264b7_MD5.png]]
![[Image/手柄焦点/ec0027ddf9ba65329789c53c0ef102c2_MD5.png]]
![[Image/手柄焦点/1acf152cf00a85d6df618047d1dd84ed_MD5.png]]
上面两个图是崩铁的手柄操作的导航 （确认 + 取消按钮）一般来说这个退出按键默认是B键（commonui自定义的按键映射），也可以通过增强输入来自定义 （commonUI默认只提供了回退按钮），
如果需要添加其他自定义按钮可以参考下图，首先添加BoundActionButton 到UI中(添加后设置此按钮折叠不显示,原因是:BoundActionBar 里面的按钮是根据数据动态创建的，它只会获取界面按钮所注册时按钮事件，并不是把按钮移动到布局里)，其次勾选DisplayInActionBar，最后需要配置导航按钮，不配置的话则不会自动添加到actionbar里
![[Image/手柄焦点/28a5c91306d04163f3f4627d8db74a98_MD5.png]]
![[Image/手柄焦点/c556797d1d8d1fae550e315baa88656d_MD5.png]]
下图的方式会自动添加返回导航按键,需要当前页面Active 如果继承了基类需要基类页面Active
![[Image/手柄焦点/7a014c7c15a0409f349b1a21dd667628_MD5.png]]
接入流程如下：
BoundActionBar:
第一步，建立自定义BoundActionBar 继承自 CommonBoundActionBar (lyra的项目中可以直接在UI左侧控件列表里找到CommonBoundActionBar,咱们的项目暂时没找到，所以先继承一层，后续可能也方便修改，建议放在c++实现LLCommonBoundActionBar)
![[Image/手柄焦点/573f37197cafd78731eb71fb6792ffcd_MD5.png]]
第二步，将CommonBoundActionBar封装成一个CommonUserWidgt，参考下图
![[Image/手柄焦点/6c678d8b12b0c122f656df9e12664500_MD5.png]]
第三步，在期望显示通用导航按钮的页面添加上刚才自定义的CommonUserWidget，如下图
![[Image/手柄焦点/3092dac0078c92c71db5e865314d702f_MD5.png]]
此时运行会发现UI上只显示 UI上本身有的按钮如下图
![[Image/手柄焦点/0a5c6318d741f6e23396de654e8ccce5_MD5.png]]
但是当我们将Option界面（上图界面）勾选上默认显示回退按钮，如下图
![[Image/手柄焦点/f9af5a797a41f65b44f34801ce99d57b_MD5.png]]
再次运行会发现，下面导航栏自动添加了回退按钮
![[Image/手柄焦点/7bfec4088e7d1acadd67bd0e445d2360_MD5.png]]
需要注意的是 Back 按钮是通用按钮对于 键鼠和手柄 都会显示，只不过显示的风格和绑定的按键不同
#### 界面按键提示逻辑
**前言：**按钮获取逻辑是递归获取 ActiveRootNode 以及其所有子界面的绑定按钮，参照下图
![[Image/手柄焦点/1ca786af4db02922df1eafcdc96a095d_MD5.png]]
![[Image/手柄焦点/c33a9abb19c566f7728a39b74c17a27c_MD5.png]]
正如上面视频所展示的那样，当我们焦点在背包道具里面的时候设置的不提示 按钮AButton，只显示Back按钮，当我们把焦点锁定到排序选择界面内的时候,按钮AButton 显示了出来（实现原理是：背包大界面勾选了 IsBackHandle && IsBackHandleDisplayedInActionBar, 排序界面在 背包界面的基础上额外又添加了 按钮 AButton 且勾选IsDisplayInActionBar） ActionBar是根据输入绑定来显示按钮的，当我们在背包界面TileView的时候 排序界面未激活只显示Back,只有当我们激活排序界面的时候，底部才会显示 排序界面所需要显示的按键（Back 和 AButton），由此可见，**ActionBar会显示最新激活界面（ActiveRootNode）的 BoundAction（ActiveRootNode注册了的的输入绑定），对于一部分简单的逻辑，我们可以通过这种方式来控制底部导航按钮提示信息，但涉及到选中之后，出现取消按钮这种情况目前还需要代码控制**
**需要注意的是：**当我们同时存在多个Widget，且有多个ActionBar，那么所有的ActionBar会显示相同的按键输入，原因是ActionBar会获取当前输入路由绑定的按键（ActiveRootNode 绑定的按键）然后更新自身,所以如果有这种情况在可能需要自己控制ActionBar的显示隐藏（暂时没发现自动处理的逻辑，也没有合适的逻辑适合封装一下，原因是：我们没办法确定什么情况下应该隐藏（叶子节点变更不合适，因为有可能我们叶子节点变更了，但是还是期望显示在唯一的ActionBar(比如展开了下拉框)，也有可能期望显示在最新的叶子节点上(比如弹出了Tips)））
![[Image/手柄焦点/bb1b03560389a5345e69669433960183_MD5.png]]
## 3DUI
3D UI没有依附图层layer所以不能激活，参考下图，当尝试激活3DUI的时候会在获取图层的逻辑被拦截掉
![[Image/手柄焦点/64d13d64f67a28e01753800b5956399f_MD5.png]]
## Lyra 设置界面拆解
Lyra的设置界面事通过注册的方式来实现的，GameSetting封装了一套 设置界面的逻辑

1. Lyra 内置了很多基础控件，通过这些界面来组装成整个设置页面

![[Image/手柄焦点/14bdef1f5657da29dbd10e58d50bf74c_MD5.png]]
2.然后添加子UI使用 GameSetting 插件
![[Image/手柄焦点/9793d73d9f8a95d41f9949e4233d568b_MD5.png]]
通过给 GaneSetting 插件的ListView 组件 设置数据（包括了基础控件类的一些配置，参考下图）
![[Image/手柄焦点/830b37345959e1bf3e9557b35a98fa1e_MD5.png]]
![[Image/手柄焦点/bc9df326e03853da88cd943c1025a17c_MD5.png]]
注册流程如下：
![[Image/手柄焦点/7a5a14c8207b6bebe741ea609285fdf2_MD5.png]]
上图的UI继承了 ULyraSettingScreen ，而 ULyraSettingScreen 继承自 UGameSettingScreen
![[Image/手柄焦点/efa5c7b9d18c91cf32b9ca6e2e09dd26_MD5.png]]
![[Image/手柄焦点/0bd2fe92422cbd203e7db63b258d7c5c_MD5.png]]
![[Image/手柄焦点/12fc11de1fd1485c43acc24cd36f11a3_MD5.png]]
然后使用上图的 CreateRegistry 接口，通过重写虚函数调用到自己实现的注册类（如下图）
![[Image/手柄焦点/08f77fe8eb850b3fcbc8fcb4b705c0f2_MD5.png]]
![[Image/手柄焦点/0f0f701fcab8ae9693df0b61dc59d8f7_MD5.png]]
## 程序逻辑
### UI激活叶子节点更新逻辑
当一个新打开的UI被设置为UI激活树的 Root节点的时候，会寻找自身挂载UI的最叶子节点作为最底层的激活UI（筛选条件要求 具体节点UI已激活 且 支持激活时聚焦）
![[Image/手柄焦点/0a25ff0274c8caa8087349a79f102b8d_MD5.png]]
![[Image/手柄焦点/cdce032896701bc9b38745a7ff025fb0_MD5.png]]
选择最底层叶子节点UI的逻辑顺序是：
第一步：根据UI结构顺序从UI的子UI列表逐个递归遍历查找最底层的UI 作为UI节点
![[Image/手柄焦点/a303f9ac5568ba15eb55b8febcc45859_MD5.png]]
第二步：当第一步第一次查找到符合条件的叶子节点后，再一次查找到可以获得UI则会根据UI层级 LayerID 来决定是否更新叶子节点的返回值，当有多个同时激活的UI在同一界面的时候会根据 layerid 来绝定到底设置哪一个UI为 最底层叶子节点UI
**重点**：接上述第二步，当我们使用排版布局来同时控制两个激活UI的时候，是没办法根据UI层级来控制 UI的layerID的，也就是说，没办法通过层级来控制设置默认激活的最底层叶子节点(LeafMostActiveWidget),比如对于下图
![[Image/手柄焦点/d980aacd4536c0cda1ade58a911c2ab4_MD5.png]]
NHorizontalBox_Content_PC 类型如果是 HorizonalBox 那么 WBP_Pack_TipsOverlay_PC 和 WBP_Pack_Tab_Overlay_PC 的layerID 将和UI顺序无关(WBP_Pack_TipsOverlay_PC：308，WBP_Pack_Tab_Overlay_PC： 297，怀疑和创建顺序有关),当我们更改NHorizontalBox_Content_PC的类型 为 OverLay, 则 产生了新的LayerID(WBP_Pack_TipsOverlay_PC:308，WBP_Pack_Tab_Overlay_PC： 339)，可见：layerID 已经和层级相关了
![[Image/手柄焦点/4521b93b137343faa154bbff2e1f5a15_MD5.png]]
注解：拿背包测试的结果是，即使我们错误的设置了叶子节点到信息页面，但是目标焦点设置为不可聚焦，且未重写默认聚焦返回按钮接口(BP_GetDesiredFocusTarget)的情况下 焦点会设置给 viewport ，对于背包的导航按键，由于背包UI本身也激活了，还是能正确收到按键事件的，逻辑上也可以设置背包list的选中项,且我们在 御魂信息面板UI上绑定了按键，那么御魂信息面板UI是需要默认激活的，否则无法收到按键按下事件
如下图：
![[Image/手柄焦点/4b90adc1ca6d5618076b4e553a42b575_MD5.png]]
可尝试拓展源码：强行指定设置叶子节点的激活UI(需要考虑万一有新UI又弹出后关闭，设置的叶子节点会不会被刷掉)
![[Image/手柄焦点/8732050ab1159d87b57f0fda927a9369_MD5.png]]
**其他解决方案：业务代码处手动设置焦点，监听输入设备变更后切换焦点，新增推荐方式：可以手动激活UI，比如 有 WidgetA 和 WidgetB 我们可以设置期望有焦点的UI默认不激活，通过程序控制UI激活顺序(需要保证不在同一帧内，delay激活期望有焦点的UI，目前测试界面需要延迟两帧，猜测可能因为UI的激活和输入路由不是同步的)**
![[Image/手柄焦点/6f77f1844c3cfdbce07de45e93eb5f9e_MD5.png]]
## LL 实现拆解
### 测试记录
####  TabListWidget 实现参考上边控件实现思路
![[Image/手柄焦点/55b10e8ce812690145983782d979876e_MD5.png]]
![[Image/手柄焦点/67d3eae4c8c76a10512a4a6442a2ed5d_MD5.png]]
#### 4. ListView设置导航
-- ListView 本身设置为 可聚焦
![[Image/手柄焦点/cf061a186e0c02e2fb23fcda0bb473cf_MD5.png]]
-- list 的EntryItem 设置为可聚焦，不默认激活（如果设置激活的话激活叶子节点就变成了最后一个添加的Entry，自动恢复聚焦等逻辑就没办法执行了）
![[Image/手柄焦点/a0a551ecaf9093e3dc29ea692d258582_MD5.png]]
-- list 里面的多个具体控件如果设置了手柄按键功能，目前的建议方式是，只显示选中行的绑定按钮，其他按钮进行折叠，同时展示出所有的按钮的话，只会响应最上层的按钮逻辑，而不是选中行的逻辑，且显示隐藏也符合游戏基本逻辑
#### 5. 具体的小控件 继承c++封装的ListEntryBase UI 
需要重写 c++ 封装的 GetPrimaryGamepadFocusWidget 接口当 listview 的选中项变更的时候可以设置默认聚焦控件，先忽略
![[Image/手柄焦点/6c2a101a8aeb26124c588da3a6704c74_MD5.png]]
### 实现注意事项（不要所有界面全部使用AvtivableWidget,输入会遍历所有这些界面）
#### Tablist

   1. Tablist 的button 需要是 CommonButtonbase 的子类
   2. 目前项目中的通用按钮 WBP_Common_Tab_PC_Cell 里面又添加了一个按钮 WBP_Common_Tab_Btn 需要去掉这个按钮或者设置为穿透点击，且需要设置为不可聚焦
   3. 如果导航按键失灵，例如按键不触发页签切换问题则可能出在没有设置 Tablist 所处的Widget 本身为 AutoActive，正确设置如下图

![[Image/手柄焦点/8d1903fd70302ee1e8ffb345d164a59c_MD5.png]]

   1. 页面切换重新设置焦点

![[Image/手柄焦点/af2aff7c0f597709d1e73e7b8ac54ab0_MD5.png]]
#### 下拉框（combox/Filter）
参考通用下拉框例子 WBP_Custom_Filter_Example
![[Image/手柄焦点/66ab26b7280dd4cae6d02fed6bd947fe_MD5.png]]
![[Image/手柄焦点/5111620e3996d9eb7561f2d8be48a95f_MD5.png]]

1. 设置默认返回焦点 重写 BP_GetDesiredFocusTarget

由于UI设计里通过按钮来触发点击展开下拉列表，所以可以将按钮设置为默认焦点控件
![[Image/手柄焦点/e1885d3bb688cbb5f3bda3319b8c8fe1_MD5.png]]
同时绑定按钮的点击事件，当期望下拉列表展开时 激活UI，当关闭下拉列表时取消激活UI，当取消激活UI后焦点回自动回到设置了自动恢复焦点的list上，原因是取消激活UI后叶子节点UI变成了list所在的UI(下面代码是现有逻辑简单加了关键调用，有优化空间，不需要完全参考)
![[Image/手柄焦点/b8ead4b983da2fd38fada500fb312eea_MD5.png]]

1. 默认返回逻辑实现 重写 BP_OnHandleBackAction

如果需要返回事件需要勾选 IsBackHandler ，根据具体使用决定是否真的需要重写 BP_OnHandleBackAction
在第一步，我们触发了按钮的点击逻辑后激活了 下拉框整个WBP_Custom_Filter_Example，此时 WBP_Custom_Filter_Example 成为了UI激活树最新的叶子节点,当我们点击手柄上的 B按键(默认的返回按键) 则会触发 WBP_Custom_Filter_Example 的 BP_OnHandleBackAction 方法，下图即是重写了这个方法，在取消ui激活的时候关闭了 下拉面板的显示
![[Image/手柄焦点/0f2c8ac33f09e9b13ef52ab73ce7c531_MD5.png]]
![[Image/手柄焦点/b84cd3db4f2c50d170f9fdaea2f0deb3_MD5.png]]

1. 下拉框展开时需要设置滚动和焦点

![[Image/手柄焦点/ccd06f1ee0906232e14535a006b7c078_MD5.png]]

1. 下拉框的点击事件区分情况使用，如果在listview中作为子项，那么可以监听listview的点击事件，如果时作为独立控件，可绑定下拉框本身结构的点击事件，都可以实现
2. 下拉框的展开面板需要设置禁止导航避免光标导航到其他界面，这个只要在下拉框基类蓝图里设置一下就行，然后作为通用组件使用

![[Image/手柄焦点/4ec21ba9ceb184d3d39cc4eb98753150_MD5.png]]

1. 下拉框里面的子项设置为 可被聚焦以便展开时聚焦

![[Image/手柄焦点/d9c463a09b97775fc7daaf26b97489d7_MD5.png]]

1. 下拉框的点击事件区分情况使用，如果在listview中作为子项，那么可以监听listview的点击事件，如果时作为独立控件，可绑定下拉框本身结构的点击事件，都可以实现
2. 下拉框默认 不激活，当需要展开下拉界面的时候由程序控制激活和取消激活
3. 下拉框的展开面板需要设置禁止导航避免光标导航到其他界面，这个只要在下拉框基类蓝图里设置一下就行，然后作为通用组件使用
##### 使用示例1 设置界面
设置界面较为特殊，不具备参考性，设置界面是封装了一层 listEntry 的子项，具体情况需要具体分析，如果实现的时候通过 listview 的item点击事件来触发则 GetPrimaryGamepadFocusWidget 可以返回 this,如果需要聚焦于具体控件则返回具体控件
![[Image/手柄焦点/72792b165dfc4be34e16d33b84102804_MD5.png]]
##### 使用设置2 背包界面排序
上面我们提到 下拉框的激活只有在页面展开的时候才给激活，正常情况下下拉框是不激活的，那么对于筛选框 其实我们会封装一层UI（WBP_Common_Rank_Example）参考下面的图
![[Image/手柄焦点/cfd70ab221064c257c8a1683c0ccab7c_MD5.png]]
这个图里包括了下拉框和排序按钮，当我们想进行排序的时候实际操作是 激活 WBP_Common_Rank_Example，然后WBP_Common_Rank_Example也设置为 支持激活的时候聚焦 和 自动恢复焦点，且我们设置默认焦点为下拉框的按钮，参考下图
![[Image/手柄焦点/0eb59b4c0dc6620ef659b31acecd3181_MD5.png]]
此时我们能够在这个界面自由导航，当焦点处于排序按钮时按下确认按钮执行按钮的点击逻辑（排序逻辑），当焦点处于下拉框的按钮的时候，点击按钮触发激活下拉框UI逻辑以及自定义逻辑（展开页面、刷新数据等等），当下拉框页面处于展开状态的时候，点击默认的返回按钮则会触发 下拉框控件的取消激活按钮
#### 进度条（AnalogSlider）

1. 继承自 AnalogSlider 进度条的控件支持使用摇杆来调整百分比，可参考样式做法：进度条作为百分比在后台调整进度，前端展示使用材质展示进度样式

![[Image/手柄焦点/ce3e9f0b64050d74067e7cd2e7768c63_MD5.png]]

1. 程序使用需要注意事项 AnalogSlider 的事件 OnValueChanged 当使用手柄的时候，参数值处于 0- 1 之间，但是使用键鼠的时候参数处于 MinValue 与 MaxValue 之间，例如设置 MinValue = 0，MaxValue = 100，当使用鼠标点击进度条中间的时候返回值是50 当使用手柄摇杆移动光标到进度条中间的时候返回值是 0.5，所以建议统一设置最大值和最小值分别是1和0，然后本次存储实际的最大值和最小值，通过百分比进行计算，可以参考下图文件

![[Image/手柄焦点/247b011e2c55745e60d7b13dc075f3e5_MD5.png]]
![[Image/手柄焦点/bb1c0d8dc585670df3449289fe6aa04b_MD5.png]]

1. 设置默认焦点

![[Image/手柄焦点/b534d728b9c5b460bf10d23b17fc8419_MD5.png]]
#### 选择框（Rotator）

1. 继承自 Rotator

选择框有两种选择方式，第一个是使焦点聚焦于 Rotator ，然后可以通过摇杆来控制左右选择如下图
![[Image/手柄焦点/1cf7500702a045a2c4638c9b95f740db_MD5.png]]

1. 也可以通过绑定按钮，在按钮逻辑中实现选择切换效果，需要注意的是如果在listview中有多个Entry都绑定了 相同的按键，需要程序逻辑控制只有当前选中的Item才设置为显示按钮，其他时候设置为折叠（Collapsed），不然会被最上层的绑定了 所按下按键 的UI处理输入，同时这也是listview中 手柄只有当前选中项才显示操作提示按钮的逻辑

![[Image/手柄焦点/57b3a7d2aba19b3b1e46b0919fa77994_MD5.png]]

1. 设置默认焦点

![[Image/手柄焦点/02c1d729f068e522b557a490acc53f8e_MD5.png]]
#### 普通点击按钮（Button）
点击按钮实现比较简单，如果是在ListView中只要注册点击事件且当使用手柄的是时候设置默认返回焦点UI为按钮即可实现点击事件
![[Image/手柄焦点/ce208925df5f672c7e395570385aae77_MD5.png]]
#### TileView
如下图所示背包界面使用了 TileView 控件
![[Image/手柄焦点/7a800985830a3752981436555c3bb336_MD5.png]]

1. 上图右侧 红框内勾选 WrapHorizontalNavigation 可以实现左侧导航逻辑（当选中最右侧item 仍向右推动摇杆 则会自动聚焦于下一行第一项），如果不勾选则会停在最右项，不会进入下一行
2. 当使用 listview，tileview 这类控件只希望焦点聚焦于其 子项 ItemEntry，不希望光标移动出去，目前的做法是需要设置不允许向外导航，参考上图右侧
3. 和 设置界面不同的是 对于背包界面我们对于item子项是不需要进行操作的，所以不需要继承自 LLListEntryBase，同时我们需要设置 listview 可聚焦和默认恢复聚焦（这一项可以让我们不需要监听输入设备的变化，当从键鼠切换到手柄，listview 会自动帮我们处理焦点恢复，这一点需要我们设置tileView 为当前页面默认焦点）设置参考下图(此项设置只有commonlistview 生效，对于UE原生的ListView和TileView，只能通过父级UI的AutoRestoreFocus实现或者是逻辑实现，逻辑实现比较靠谱)

**强烈推荐使用 commonUI的 listview 和 tileview，好处是：方便从其他界面切换节点到 view的时候commonUI有上述配置帮我们自动切换到上次的默认选项 ！！！不需要写额外的跳转逻辑**
![[Image/手柄焦点/ffef363ee9a4fc1455dcb3876d1a1c09_MD5.png]]
![[Image/手柄焦点/5ce4d5ca483fd92acb78ef0d5ad54c50_MD5.png]]
代码逻辑参考下图
![[Image/手柄焦点/a299bf1f91d1fb45b17db8ea67c692fa_MD5.png]]
![[Image/手柄焦点/77dbc0f91ccecc394c9df0a5e0e0efc8_MD5.png]]
#### ScrollBox
主要实现功能为 ScrollBox的滚动，由于UE和CommonUI本身都不支持这种效果，所以我们需要模拟实现这种效果
##### 拓展源码
![[Image/手柄焦点/645c60abb9509a622e4642976b85482c_MD5.png]]
![[Image/手柄焦点/40e5f532a6889b7db0e06b6dc8854ead_MD5.png]]
![[Image/手柄焦点/859ae0e579210d3b58844d478634f55f_MD5.png]]
![[Image/手柄焦点/1e631776eb647f9505c27fb9e90004b5_MD5.png]]
##### 外部调用
commonUI 不支持轴输入，所以我们需要通过定时器绑定右侧摇杆的上下推的 pressed 和 released事件来模拟实现这种效果，推上去的时候启动定时器移动指定步长(有动画过度),停止的时候自动还原回去
![[Image/手柄焦点/785351dad803066402d36de9031a7710_MD5.png]]
![[Image/手柄焦点/a5c398345641cbb9eb7d0470f4c31b3f_MD5.png]]
![[Image/手柄焦点/9c56d24370152c4e0065b444ee433944_MD5.png]]
#### 区块UI焦点切换实现方案
##### 7 UI实际表现
如下图所示，当处于背包界面的时候正常导航是光标是无法进入 物品排列筛选器的
##### 2. 实现思路
第一步：将筛选器和排序按钮做成通用的一个UI用来制作条件排序功能
![[Image/手柄焦点/5bf6f251dc4c13d392be96cd425f5994_MD5.png]]
第二步：设置UI默认不激活
![[Image/手柄焦点/0ffcc94dc1f44d515d72478255d25b7a_MD5.png]]
第三步：设置下拉框和按钮可以focus，使得这个UI激活的时候可以在这两个控件之中导航
![[Image/手柄焦点/f43862f8c98274bab789b5965b30d6e2_MD5.png]]
![[Image/手柄焦点/fc16b1396b814ad9fdaf63a1c46eed88_MD5.png]]
第四步：设置此UI默认焦点控件,这部分可以写在ts里
![[Image/手柄焦点/abbbde358e1ca851162c76eacb4317fb_MD5.png]]
第五步：绑定一个按键，这个按键的功能是激活此界面，参考背包例子如下：当按下左侧摇杆按下按钮，触发激活UI逻辑
![[Image/手柄焦点/0b38290facd5757e2996e8ad8174c687_MD5.png]]
工作原理：当新的UI激活时它会成为UI激活树的末端节点进而走到如下逻辑处
![[Image/手柄焦点/6d0aecaff8e5934fb6e0181f594c8ee8_MD5.png]]
第六步：
当我们激活了主UI上的其中一个子UI，例如上述筛选器，我们的焦点被 限制在了这个新的UI中当期望返回背包焦点的时候，我们只需要Deactive之前激活的子UI即可恢复之前的UI激活状态(对于背包就是焦点恢复到tileview中，其他的应该是恢复到之前的焦点控件)，便捷的方式是勾选下图配置，引擎默认代码会deactive UI，注意：如果自己实现了BP_OnHandleBackAction 则需要自己处理逻辑
![[Image/手柄焦点/3d716070ab4459bcd5fd62f2a07f6be7_MD5.png]]
![[Image/手柄焦点/4bf0bc0b5f4ac64697228aebdd453959_MD5.png]]
#### 双激活界面焦点导航方案
##### 8 实现目标
星铁主界面 按钮所在 view 到 设置列表UI导航，参照如下视频：
##### 2. 实现猜想设计
参照上面视频，星铁的主界面和设置界面可能是两个独立分离的界面，且左侧是一个 TileView 列表，右侧是一个Widget里面放置了四个按钮，按照这个UI结构设置做出了如下结构的UI
![[Image/手柄焦点/c786052a02c485e0b1e1442aaf5b82bf_MD5.png]]
WBP_MainMenuTest 和 WBP_SettingBtnList 是两个独立的UI，我们默认给 WBP_SettingBtnList 激活，WBP_MainMenuTest 延迟两帧激活保证 最叶子节点焦点UI在 TileView ( WBP_MainMenuTest ) 中，且不对控件导航进行任何干预，效果如下视频：
**需要注意的是：**上面的视频我们对两个UI都进行了激活，是因为 WBP_SettingBtnList 界面绑定了快捷键需要激活接受按键输入，如果没有按键需求的话，我们是可以不激活 WBP_SettingBtnList 界面的，**界面的激活与否不影响导航**
上述视频存在待解决的问题：
a. 我们无法像星铁一样在光标导航到 界面 WBP_SettingBtnList 始终保持按钮聚焦在 第一个按钮
b. 视频中，有一段时间 有一段时间光标一直停留在 第一个按钮（Y按钮），此时我的操作并没有停止，但是由于UE的默认导航规则是根据 焦点位置 算一些偏移相关的东西，如果左侧找不到可聚焦控件就会停止导航
![[Image/手柄焦点/8972fb466ec92e85eaa341e8ffe9e53e_MD5.png]]
##### 3. 干预导航 解决第二步出现的问题
解决问题a：为了能让焦点切换到 WBP_SettingBtnList 的时候永远聚焦于第一个按钮，做出如下导航干涉(这部分可以在代码里实现，没具体实现，但是有接口可以设置)，下面两个图主要逻辑是：当导航想右侧脱离WBP_MainMenuTest 进入新界面的时候，指定导航目标为 WBP_SettingBtnList 的按钮 UI_Button_1（**设置导航规则的控件不必为具体空间，设置其parent节点的导航规则也是可以的**）
![[Image/手柄焦点/aa9db1cd91482312d678edba083d3ebd_MD5.png]]
![[Image/手柄焦点/645be48c9a2609898838557d5909c2eb_MD5.png]]
解决问题b：原理同上，设置 WBP_SettingBtnList 的导航规则，**解释一下下面的导航规则逻辑：**
如果我们期望焦点返回上次光标所在的位置，我们可以直接设置 ReturnNode = MenuTileView，但是考虑到星铁焦点是默认返回第一个道具，所以如果我们想按照星铁的实现方式，可以先设置 MenuTileView选中 第一项道具，然后再设置 ReturnNode = MenuTileView，这样当焦点重新导航回 TileView 的时候会默认选中第一项（原理是tileview设置了自动恢复选中项，而我们又提前设置了选中项）
![[Image/手柄焦点/0247bf25b290a50410e645ce8f54cff5_MD5.png]]
![[Image/手柄焦点/e94d9630d5c0df0f8c6db1a60989ac02_MD5.png]]
经过上面两步我们基本已经完全复刻了星铁的主界面关键部分，效果如下
同一激活界面双焦点导航方案
### 未解问题
#### 9 最父级UI设置自动激活导致 UI设置焦点失败问题
场景：如下图，CD_WebInfo 是一个新展开的界面，内置了两个子UI关联switcher，重写了 Bp_GetDesireFocusTarget() 返回其中一个UI上的按钮，如果设置 CD_WebInfo 自动激活，日志显示焦点设置到了目标按钮，但是实际上焦点暂时不能导航，需要切换一下手柄键鼠或者按以下 手柄确认按键焦点才能过去，如果不设置 CD_WebInfo 自动激活 则不会出现这种问题，暂时还不知道为什么
![[Image/手柄焦点/37b755655b0cec7e07f12f606e647bbe_MD5.png]]
补充：又复现了一次，这次是设置焦点到list也没办法上来就得到焦点（手动调用代码navigatetoindex 可以解决list的问题）
