# 相关参考
- **游戏开发中的阻尼器和阻尼弹簧**	[https://zhuanlan.zhihu.com/p/461813778](https://zhuanlan.zhihu.com/p/461813778)
- **相机基础流程**  [mp.weixin.qq.com/s?\_\_biz=MzUxMDM3MTYwNQ\==&mid=2247515300&idx=1&sn=9d5541a39509ee76f352f71b5d23396d&chksm=f9010edece7687c873df25965408a79c6097321ae8be62e61f9d5a164ddd36047acd1810851e&token=1293963636&lang=zh\_CN#rd](https://mp.weixin.qq.com/s?__biz=MzUxMDM3MTYwNQ==&mid=2247515300&idx=1&sn=9d5541a39509ee76f352f71b5d23396d&chksm=f9010edece7687c873df25965408a79c6097321ae8be62e61f9d5a164ddd36047acd1810851e&token=1293963636&lang=zh_CN)
---
# 相机投影
相机投影分为两种、正交投影和透视投影、区别如下

![[Pasted image 20240202152518.png]]

	投影方式设置位置：
		Perspective：透视投影
		Orthographic：正交投影
	
![[Pasted image 20240202161848.png]]

---
# 基础概念
**位置**、**朝向**、**视野(FOV)** 这三个参数是相机系统最核心的内容，把他们组装起来就是常说的 POV（Point Of View，还包含其它的参数），你会在代码中经常看到它

---
# 基础更新流程
## PlayerController
	Playercontroller 管理了相机管理类 APlayerCameraManager
``` cpp
	/** Camera manager associated with this Player Controller. */
	UPROPERTY(BlueprintReadOnly, Category=PlayerController)
	TObjectPtr<APlayerCameraManager> PlayerCameraManager;
```
- 在关卡的 Tick 中 获取当前的 PlayerController 然后调用 UpdateCameraManager 接口来更新相机
```cpp
// Update cameras last. This needs to be done before NetUpdates, and after all actors have been ticked.
for( FConstPlayerControllerIterator Iterator = GetPlayerControllerIterator(); Iterator; ++Iterator )
{
    if (APlayerController* PlayerController = Iterator->Get())
    {
        if (!bIsPaused || PlayerController->ShouldPerformFullTickWhenPaused())
        {
            PlayerController->UpdateCameraManager(DeltaSeconds);
        }
        else if (PlayerController->PlayerCameraManager && FCameraPhotographyManager::IsSupported(this))
        {
            PlayerController->PlayerCameraManager->UpdateCameraPhotographyOnly();
        }
    }
}
```
- 下一步 PlayerController 的更新接口 UpdateCameraManager 调用 PlayerCameraManager 的更新接口 UpdateCamera 进行真正的相机逻辑更新
---
## PlayerCameraManager
- 上面说到 PlayerCameraManager 里的接口 UpdateCamera 是真正执行相机 POV 更新的地方，UpdateCamera 接口会调用 DoUpdateCamera
	- PlayerCameraManager 的 UpdateCamera 方法主要逻辑如下：
		1. DoUpdateCamera 处理 ViewTarget 和 PendingViewTarget 的**更新**(调用 UpdateViewTarget )与**融合**逻辑
		2. UpdateViewTarget 根据 ViewTarget 内的 Target 计算对应的 POV 信息**（核心逻辑）**
		3. ApplyCameraModifiers 处理特殊的镜头需求；比如：CameraShake、粒子效果等
		4. UpdateCameraLensEffects 处理特殊镜头效果；比如：景深、边缘模糊、色彩校正等+
		5. 缓存相机数据 FillCameraCache (NewPOV)，用于渲染 
```cpp
void APlayerCameraManager::UpdateCamera(float DeltaTime)
{
	check(PCOwner != nullptr);

	if ((PCOwner->Player && PCOwner->IsLocalPlayerController()) || !bUseClientSideCameraUpdates || bDebugClientSideCamera)
	{
        // 省略部分的代码
		DoUpdateCamera(DeltaTime);
    	UpdateViewTarget(ViewTarget, DeltaTime);
        ApplyCameraModifiers(DeltaTime, OutVT.POV);
        UpdateCameraLensEffects(OutVT);
    }
```
- 下面的代码是 DoUpdateCamera 的部分逻辑
```cpp
void APlayerCameraManager::DoUpdateCamera(float DeltaTime)
{
	FMinimalViewInfo NewPOV = ViewTarget.POV;

	// 省略部分代码
	// Don't update outgoing viewtarget during an interpolation when bLockOutgoing is set.
	if ((PendingViewTarget.Target == NULL) || !BlendParams.bLockOutgoing)
	{
		// Update current view target
		ViewTarget.CheckViewTarget(PCOwner);
		UpdateViewTarget(ViewTarget, DeltaTime);
	}

	// 省略部分代码

	// if we have a pending view target, perform transition from one to another.
	if (PendingViewTarget.Target != NULL)
	{
        // 省略部分代码
		// Update pending view target
		PendingViewTarget.CheckViewTarget(PCOwner);
		UpdateViewTarget(PendingViewTarget, DeltaTime);

        // 省略下面部分的代码
    }
}
```
- PlayerCameraManger 根据 ViewTarget 内 Target 对象的信息来计算并刷新 POV，随后这个 POV 信息会被 ULocalPlayer 用到渲染的透视投影或正交投影矩阵中，将相机视野范围内的内容渲染到屏幕上
-  在 DoUpdateCamera 接口内存在一个关键的信息结构 FMinimalViewInfo & 关键的接口 UpdateViewTarget，而且 PlayerCameraManager 中 存储了 ViewTarget（FTViewTarget），FTViewTarget结构如下
```cpp
/** A ViewTarget is the primary actor the camera is associated with. */
USTRUCT(BlueprintType)
struct ENGINE_API FTViewTarget
{
	// 相机跟随的目标
	/** Target Actor used to compute POV */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TViewTarget)
	TObjectPtr<class AActor> Target;

	// 摄像机实际的POV
	/** Computed point of view */
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category=TViewTarget)
	struct FMinimalViewInfo POV;

	// 省略部分代码
};
```
- 在 DoUpdateCamera 接口里调用 UpdateViewTarget 接口根据跟随目标 计算相机的新的 POV 位置，而 UpdateViewTarget 又是根据 相机组件的接口 GetCameraView 获取新的相机 POV 信息，如下图
```cpp
void APlayerCameraManager::UpdateViewTarget(FTViewTarget& OutVT, float DeltaTime)
{
	// 省略部分代码
	if (ACameraActor* CamActor = Cast<ACameraActor>(OutVT.Target))
	{
		// Viewing through a camera actor.
		CamActor->GetCameraComponent()->GetCameraView(DeltaTime, OutVT.POV);
	}
    // 省略部分代码
}
```
- GetCameraView 是一个虚函数，可以通过自定义的相机组件 NCameraComponent 来 根据不同的相机模式策略更新相机 DesiredView 信息 ^677221
- 相机修改的关键干涉点是修改相机的POV，即通过 相机组件CameraComponent 重写 GetCameraView 接口来实现自定义修改过后的 FMinimalViewInfo 信息，DesiredView 的信息是相机组件最终的位置信息
```cpp
virtual void GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView) override;

void UNCameraComponent::GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView)
{
	FNCameraModeView CameraModeView;
	// 没有设置相机模式走父类逻辑；否则走相机模式逻辑
	if (!CameraModeStack || (!CameraModeStack->EvaluateStack(DeltaTime, CameraModeView)))
	{
		Super::GetCameraView(DeltaTime, DesiredView);
	}
	else
	{
		// Keep player controller in sync with the latest view.
		if (APawn* TargetPawn = Cast<APawn>(GetParentActor()))
		{
			if (APlayerController* PC = TargetPawn->GetController<APlayerController>())
			{
				PC->SetControlRotation(CameraModeView.ControlRotation);
			}
		}
		GetPOICameraManager()->UpdateRotation(DeltaTime,CameraModeView);
		// Keep camera component in sync with the latest view.
		SetWorldLocationAndRotation(CameraModeView.Location, CameraModeView.Rotation);
		FieldOfView = CameraModeView.FieldOfView;

		// Fill in desired view.
		DesiredView.Location = CameraModeView.Location;
		DesiredView.Rotation = CameraModeView.Rotation;
		DesiredView.FOV = CameraModeView.FieldOfView;
		DesiredView.OrthoWidth = OrthoWidth;
		DesiredView.OrthoNearClipPlane = OrthoNearClipPlane;
		DesiredView.OrthoFarClipPlane = OrthoFarClipPlane;
		DesiredView.AspectRatio = AspectRatio;
		DesiredView.bConstrainAspectRatio = bConstrainAspectRatio;
		DesiredView.bUseFieldOfViewForLOD = bUseFieldOfViewForLOD;
		DesiredView.ProjectionMode = ProjectionMode;
		// See if the CameraActor wants to override the PostProcess settings used.
		DesiredView.PostProcessBlendWeight = PostProcessBlendWeight;
		if (PostProcessBlendWeight > 0.0f)
		{
			DesiredView.PostProcessSettings = PostProcessSettings;
		}	
	}
}
```

---
# 基本构成
## 相机组件 CameraComponent
### **成员**
- 半透效果配置   FNActorFading ActorFadingProp 
- 相机模式栈 	UNCameraModeStack* CameraModeStack 

 ``` cpp
 class UNCameraModeStack : public UObject  
{  
	GENERATED_BODY()  
	  
	void PushCameraMode(UNCameraModeBase* CameraModeInstance, AActor* TargetActor);  
	void ClearStack();  
	bool EvaluateStack(float DeltaTime, FNCameraModeView& OutCameraModeView);  
	UNCameraModeBase* GetCameraModeInstance(TSubclassOf<UNCameraModeBase> CameraModeClass);  
	bool UpdateStack(float DeltaTime);  
	void BlendStack(FNCameraModeView& OutCameraModeView, float DeltaTime) const;  

	// 相机模式实例列表所有创建的相机模式实例存储于此列表
	TArray<UNCameraModeBase*> CameraModeInstances;
	// 相机模式过渡栈，有新的需要过渡的相机模式的话会塞到这个列表种参与过渡
	TArray<UNCameraModeBase*> CameraModeStack;  
};
```

^559a91

- 当前激活相机优先级栈(会同时存在多个优先级) TArray\<FCameraModeStackEntry> CameraModePriorityStack;
- 默认相机模式    TSubclassOf\<UNCameraModeBase> DefaultCameraMode
### **方法**
- virtual void OnComponentCreated() override;  
- virtual void InitializeComponent() override;  
- virtual void GetCameraView(float DeltaTime, FMinimalViewInfo& DesiredView) override;
		主要干涉函数，通过重写此函数返回计算后的 POV 信息
### 简述
- 相机组件充当着引擎接入与自定义相机表现的中间件，负责管理相机模式，包括相机模式的入栈出栈

---
# 实际流程
## 相机的初始化
- 角色进入关卡设置默认游戏相机
``` cpp
// 设置相机默认模式的话如果当前已经存在默认相机模式则需要
void UNCameraComponent::SetDefaultCameraMode(const TSubclassOf<UNCameraModeBase> NewDefaultCameraMode)  
{  
	if (NewDefaultCameraMode && DefaultCameraMode != NewDefaultCameraMode )  
	{  
		PushCameraMode(NewDefaultCameraMode);  
		if (DefaultCameraMode)  
		{  
			PullCameraModeInstance(GetCameraModeInstance(DefaultCameraMode));  
		}  
		DefaultCameraMode = NewDefaultCameraMode;  
	}  
}

// 根据相机模式类获取相机模式示例
FNGameCameraModeHandle UNCameraComponent::PushCameraMode(TSubclassOf<UNCameraModeBase> CameraModeClass, int32 Priority)  
{  
	if (!CameraModeStack)  
	{  
		return FNGameCameraModeHandle();  
	}  
	  
	return PushCameraModeUsingInstance(GetCameraModeInstance(CameraModeClass), Priority);  
}

// 存在相机模式实例则使用否则重新创建一个新的模式实例
UNCameraModeBase* UNCameraModeStack::GetCameraModeInstance(TSubclassOf<UNCameraModeBase> CameraModeClass)  
{  
	check(CameraModeClass);  
	  
	// First see if we already created one.  
	for (UNCameraModeBase* CameraMode : CameraModeInstances)  
	{  
		if ((CameraMode != nullptr) && (CameraMode->GetClass() == CameraModeClass))  
		{  
			return CameraMode;  
		}  
	}  
  
// Not found, so we need to create it.  
	UNCameraModeBase* NewCameraMode = NewObject<UNCameraModeBase>(GetOuter(), CameraModeClass, NAME_None, RF_NoFlags);  
	check(NewCameraMode);  
	CameraModeInstances.Add(NewCameraMode);  
	return NewCameraMode;  
}

```

## 相机的切换

 ### 角色状态变更切换 & 新相机模式的 入栈 与 出栈
- 新相机模式的 入栈 与 出栈
		举个攀爬相机切换的例子，进入攀爬相机也是走的状态切换不同的是从默认相机进入攀爬相机不存在旧的相机模式出栈（与具体业务逻辑有关）
		一般情况来说 CameraModePriorityStack 相机模式优先级列表种，通过初始化后总会存在一个默认的相机模式，这个后边的调试代码能看到	
		![[Pasted image 20240202174706.png]]
	- 我们先来看 默认休闲相机进入攀爬相机的过程，当角色进入攀爬状态的时候不存在旧相机模式出栈，只有新的相机模式入栈，下图是调试的堆栈：可以看到相机模式的优先级列表 CameraModePriorityStack 种存在两个相机模式，分别是默认相机模式和攀爬相机模式，默认相机模式是常驻的优先级最低为0，攀爬相机模式是新入栈的优先级比较高为100，所以在之后的 UpdateBlendingStack 函数内根据相机模式的优先级重新决定当前应该使用的相机模式
		![[Pasted image 20240202175252.png]]	
	- 那么我们再来看下 UpdateBlendingStack 具体执行了什么逻辑，核心的执行逻辑在于 推送新的队列列表种优先级最高的相机模式到当前正在使用的栈列表（CameraModeStack）之中，CameraModeStack 中还管理了一个相同名称列表 CameraModeStack，称之为混合队列，详细结构参考:[[#^559a91]]，
	- 混合队列中 EvaluateStack 每帧执行混合逻辑，UpdateStack 负责计算混合百分比参数，同时 也调用了 UpdateView_Implementation 的具体实现来接入业务逻辑上相机模式的具体计算结果，也就是说: 自定义的相机模式 通过重写 UpdateView_Implementation 实现每个相机模式自己的视觉表现，然后相机模式栈通过每帧调用 UpdateStack 进而调用到 相机模式 的 UpdateCameraMode 接口 再进而调用到 UpdateView 接口实现每个相机模式的独立参数计算 ，BlendStack负责具体的 View 信息过渡
	- 那么 EvaluateStack 又是在哪里被调用的呢？我们在上文说过 可以通过重写相机组件的 GetCameraView 函数来实现 [[#^677221]]，所以只要我们在 GetCameraView 这个接口中调用 EvaluateStack 即可实现相机模式的 Blend
	- 部分伪代码如下
		``` cpp
		void UNCameraComponent::UpdateBlendingStack()  
		{  
			if (!CameraModeStack)  return;  
			// 当前一个相机模式都没有，那就push一个默认的相机模式入栈  
			if (CameraModePriorityStack.Num() <= 0)  
			{  
				PushCameraMode(DefaultCameraMode);  
			}  

			// 推送新模式入栈
			AActor* TargetActor = GetOwnerActor();  
			CameraModeStack->PushCameraMode(CameraModePriorityStack.Top().CameraMode, TargetActor);  
			  
			if(CameraModePriorityStack.Top().CameraMode != LastCameraMode)  
			{  
			// 伪代码代码：通用规则，如果是在弹簧臂模式下，上一个模式的弹簧臂长度比新的模式的弹簧臂长度要长，那么就把新的弹簧臂设置成跟上一个一样。  

			// 相机切换后通知  
			if (const UGlobalDelegatesSubsystem* DelegatesSubsystem = UGlobalDelegatesSubsystem::Get<UGlobalDelegatesSubsystem>(this))  
			{  
				DelegatesSubsystem->OnCameraModeChange.Broadcast(this, LastCameraMode.Get(), CameraModePriorityStack.Top().CameraMode);  
			}  
			// 记录上一个相机模式  
			LastCameraMode = CameraModePriorityStack.Top().CameraMode;  
			}  
		}
		```
# 一些问题功能点的实现方案
## 视点偏移问题
- 效果预览：缩进相机臂长的时候视点上升（绿色小球是视点的位置），玩家无论是通过滚轮还是在墙壁边上旋转，只要从使得臂长变化相机的视点就会根据配置变更
![[Image/相机视点调整.gif]]
- 实现逻辑：配置一条和相机臂长相关的曲线（横轴：相机臂长，纵轴：视点偏移值），关键点：先通过 PivotOffset(玩家自定义的视点偏移，可通过曲线动态调整) 的 Z 轴值偏移调整视点的偏移，XY轴的偏移调整根据视点计算出的视口的偏移（XY轴如果偏移计算到视点上的话在一些情况可能导致视点算入墙面，从而和墙体产生Block导致相机异常推进）
``` cpp
	伪代码：调整视点Z
	FVector GoalCameraLoc = NewView.PivotLocation + FRotationMatrix(SmoothedRotation).TransformVector(FVector(0, 0, PivotOffset.Z));
	伪代码：调整视口的XY偏移值
	DesiredLoc += FRotationMatrix(DesiredRot).TransformVector(FVector(PivotOffset.X, PivotOffset.Y, 0));
	伪代码：在视点位置和计算后的视口位置之间打实现选择新的摄像机视口位置（为了处理碰撞问题）

```
## 过渡
- 每个相机模式都会配置默认的过渡配置索引到一个DT表配置一些 混入参数
	![[Image/Pasted image 20240204173950.png]]
- 此外相机模式之间的过渡是可以单独配置的，新旧相机模式切换的时候也可以指定两种相机模式过渡的参数，如果指定了过渡方式则采用指定的过渡参数过渡，否则使用默认的过渡参数进行过渡
	![[Image/Pasted image 20240204174044.png]]
- 过渡方式参数合集
	![[Image/Pasted image 20240204174232.png]]